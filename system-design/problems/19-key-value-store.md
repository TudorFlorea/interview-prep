# Design Distributed Key-Value Store

[â† Back to Problems](/system-design/problems/00-index.md)

---

## ğŸ¯ Problem Statement

Design a distributed key-value store (like DynamoDB, Cassandra, or Redis Cluster) that provides high availability, partition tolerance, and configurable consistency.

**Difficulty**: ğŸ”´ Hard (Tier 1)

---

## 1. Requirements Gathering

### Functional Requirements

1. **Put(key, value)** - Store data
2. **Get(key)** - Retrieve data
3. **Delete(key)** - Remove data
4. **TTL support** - Auto-expiration
5. **Range queries** - Optional, ordered keys
6. **Atomic operations** - CAS, increment

### Non-Functional Requirements

| Aspect | Requirement |
|--------|-------------|
| **Availability** | 99.99% |
| **Latency** | &lt; 10ms p99 |
| **Scalability** | Petabytes of data |
| **Durability** | No data loss |
| **Consistency** | Tunable (eventual to strong) |

---

## 2. Back of Envelope Calculations

```
Data Volume:
- 1 billion keys
- Average value size: 1 KB
- Total: 1 TB data

Traffic:
- 100K read/second
- 10K write/second

Replication:
- 3 replicas per key
- Total storage: 3 TB

Nodes:
- 500 GB per node
- 6 nodes minimum for data
- 3 nodes for coordination
```

---

## 3. Core Concepts

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   KEY-VALUE STORE CONCEPTS                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  Data Model:                                                    â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                   â”‚
â”‚  key (string) â†’ value (bytes) + metadata                      â”‚
â”‚                                                                 â”‚
â”‚  Metadata:                                                      â”‚
â”‚  â€¢ version (vector clock or timestamp)                        â”‚
â”‚  â€¢ ttl (expiration time)                                      â”‚
â”‚  â€¢ checksum                                                    â”‚
â”‚                                                                 â”‚
â”‚  Storage Format:                                                â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  key_len â”‚  key  â”‚ value_len â”‚ value â”‚ version â”‚ ttl  â”‚   â”‚
â”‚  â”‚   4B     â”‚  var  â”‚    4B     â”‚  var  â”‚   8B    â”‚  8B  â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                 â”‚
â”‚  Operations:                                                    â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                   â”‚
â”‚  PUT(key, value, options)  â†’ success/error                    â”‚
â”‚  GET(key, options)         â†’ value/not_found                  â”‚
â”‚  DELETE(key)               â†’ success/error                    â”‚
â”‚  CAS(key, expected, new)   â†’ success/conflict                 â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 4. High-Level Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   DISTRIBUTED KEY-VALUE STORE                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                            â”‚
â”‚      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                            â”‚
â”‚      â”‚  Client  â”‚  â”‚  Client  â”‚  â”‚  Client  â”‚                            â”‚
â”‚      â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜                            â”‚
â”‚           â”‚             â”‚             â”‚                                    â”‚
â”‚           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                   â”‚
â”‚                         â”‚                                                  â”‚
â”‚                         â–¼                                                  â”‚
â”‚               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                       â”‚
â”‚               â”‚   Coordinator     â”‚                                       â”‚
â”‚               â”‚   (any node)      â”‚                                       â”‚
â”‚               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                       â”‚
â”‚                         â”‚                                                  â”‚
â”‚            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                    â”‚
â”‚            â”‚            â”‚            â”‚                                    â”‚
â”‚            â–¼            â–¼            â–¼                                    â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                         â”‚
â”‚    â”‚   Node 1    â”‚â”‚   Node 2    â”‚â”‚   Node 3    â”‚                         â”‚
â”‚    â”‚ (Primary)   â”‚â”‚ (Replica)   â”‚â”‚ (Replica)   â”‚                         â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜                         â”‚
â”‚           â”‚              â”‚              â”‚                                 â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”                         â”‚
â”‚    â”‚  Storage    â”‚â”‚  Storage    â”‚â”‚  Storage    â”‚                         â”‚
â”‚    â”‚  Engine     â”‚â”‚  Engine     â”‚â”‚  Engine     â”‚                         â”‚
â”‚    â”‚  (LSM/B+)   â”‚â”‚  (LSM/B+)   â”‚â”‚  (LSM/B+)   â”‚                         â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                         â”‚
â”‚                                                                            â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚    â”‚                    Hash Ring (Consistent Hashing)              â”‚    â”‚
â”‚    â”‚                                                                 â”‚    â”‚
â”‚    â”‚    â”Œâ”€â”€â”€â”     â”Œâ”€â”€â”€â”     â”Œâ”€â”€â”€â”     â”Œâ”€â”€â”€â”     â”Œâ”€â”€â”€â”     â”Œâ”€â”€â”€â”   â”‚    â”‚
â”‚    â”‚    â”‚N1 â”‚â”€â”€â”€â”€â”€â”‚N2 â”‚â”€â”€â”€â”€â”€â”‚N3 â”‚â”€â”€â”€â”€â”€â”‚N4 â”‚â”€â”€â”€â”€â”€â”‚N5 â”‚â”€â”€â”€â”€â”€â”‚N6 â”‚   â”‚    â”‚
â”‚    â”‚    â””â”€â”€â”€â”˜     â””â”€â”€â”€â”˜     â””â”€â”€â”€â”˜     â””â”€â”€â”€â”˜     â””â”€â”€â”€â”˜     â””â”€â”€â”€â”˜   â”‚    â”‚
â”‚    â”‚                                                                 â”‚    â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                                                                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 5. Deep Dive: Partitioning

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   CONSISTENT HASHING                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  Hash Ring:                                                     â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                   â”‚
â”‚  â€¢ Hash keys and nodes to same space (0 to 2^128)             â”‚
â”‚  â€¢ Key assigned to first node clockwise                       â”‚
â”‚                                                                 â”‚
â”‚                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”                                   â”‚
â”‚                â”Œâ”€â”€â”€â”‚  N1   â”‚â”€â”€â”€â”                               â”‚
â”‚            â”Œâ”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”                           â”‚
â”‚       â”Œâ”€â”€â”€â”€â”˜                       â””â”€â”€â”€â”€â”                      â”‚
â”‚    â”Œâ”€â”€â”´â”€â”€â”                           â”Œâ”€â”€â”´â”€â”€â”                   â”‚
â”‚    â”‚ N6  â”‚     Keys A, B, C          â”‚ N2  â”‚                   â”‚
â”‚    â”‚     â”‚     hash to this          â”‚     â”‚                   â”‚
â”‚    â””â”€â”€â”¬â”€â”€â”˜     segment â†’ N2          â””â”€â”€â”¬â”€â”€â”˜                   â”‚
â”‚       â””â”€â”€â”€â”€â”                       â”Œâ”€â”€â”€â”€â”˜                      â”‚
â”‚            â””â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”˜                           â”‚
â”‚                â””â”€â”€â”€â”‚  N3   â”‚â”€â”€â”€â”˜                               â”‚
â”‚                    â””â”€â”€â”€â”€â”€â”€â”€â”˜                                   â”‚
â”‚                                                                 â”‚
â”‚  Virtual Nodes:                                                 â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                â”‚
â”‚  â€¢ Each physical node has 100+ virtual nodes                  â”‚
â”‚  â€¢ Better distribution                                         â”‚
â”‚  â€¢ Easier rebalancing                                          â”‚
â”‚                                                                 â”‚
â”‚  Finding Nodes:                                                 â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                â”‚
â”‚  def get_nodes(key, replication_factor=3):                    â”‚
â”‚      hash = md5(key)                                          â”‚
â”‚      pos = binary_search(ring, hash)                          â”‚
â”‚      nodes = []                                                â”‚
â”‚      while len(nodes) < replication_factor:                   â”‚
â”‚          node = ring[pos % len(ring)]                         â”‚
â”‚          if node.physical not in nodes:                       â”‚
â”‚              nodes.append(node.physical)                      â”‚
â”‚          pos += 1                                             â”‚
â”‚      return nodes                                              â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 6. Deep Dive: Replication

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   REPLICATION STRATEGIES                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  Replication Factor (N):                                        â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                      â”‚
â”‚  â€¢ N = 3: Each key stored on 3 nodes                          â”‚
â”‚  â€¢ Replicas on consecutive nodes in ring                      â”‚
â”‚                                                                 â”‚
â”‚  Write Path:                                                    â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                   â”‚
â”‚  1. Client sends write to coordinator                         â”‚
â”‚  2. Coordinator finds N replicas for key                      â”‚
â”‚  3. Coordinator sends write to all N replicas                 â”‚
â”‚  4. Waits for W acknowledgments (quorum)                      â”‚
â”‚                                                                 â”‚
â”‚  Read Path:                                                     â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                    â”‚
â”‚  1. Client sends read to coordinator                          â”‚
â”‚  2. Coordinator sends read to N replicas                      â”‚
â”‚  3. Waits for R responses                                     â”‚
â”‚  4. Returns latest version (highest timestamp/version)        â”‚
â”‚                                                                 â”‚
â”‚  Quorum:                                                        â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                      â”‚
â”‚  W + R > N guarantees overlap (read sees latest write)        â”‚
â”‚                                                                 â”‚
â”‚  Configurations:                                                â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                               â”‚
â”‚  N=3, W=2, R=2: Strong consistency, good availability        â”‚
â”‚  N=3, W=1, R=1: Eventual consistency, highest availability   â”‚
â”‚  N=3, W=3, R=1: Read-optimized                               â”‚
â”‚  N=3, W=1, R=3: Write-optimized                              â”‚
â”‚                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  Write: W=2                    Read: R=2               â”‚   â”‚
â”‚  â”‚                                                         â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”                     â”Œâ”€â”€â”€â”€â”€â”€â”€â”              â”‚   â”‚
â”‚  â”‚  â”‚ Node1 â”‚ âœ“ ACK              â”‚ Node1 â”‚ v=5 âœ“        â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”˜                     â””â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”                     â”Œâ”€â”€â”€â”€â”€â”€â”€â”              â”‚   â”‚
â”‚  â”‚  â”‚ Node2 â”‚ âœ“ ACK              â”‚ Node2 â”‚ v=5 âœ“        â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”˜                     â””â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”                     â”Œâ”€â”€â”€â”€â”€â”€â”€â”              â”‚   â”‚
â”‚  â”‚  â”‚ Node3 â”‚ (async)            â”‚ Node3 â”‚ (not needed) â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”˜                     â””â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚   â”‚
â”‚  â”‚                                                         â”‚   â”‚
â”‚  â”‚  2 ACKs received              Return v=5              â”‚   â”‚
â”‚  â”‚  â†’ Write succeeds             (latest version)        â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 7. Deep Dive: Conflict Resolution

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   CONFLICT RESOLUTION                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  Problem: Concurrent writes to same key on different nodes    â”‚
â”‚                                                                 â”‚
â”‚  Option 1: Last-Writer-Wins (LWW)                              â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                              â”‚
â”‚  â€¢ Attach timestamp to each write                             â”‚
â”‚  â€¢ Highest timestamp wins                                      â”‚
â”‚  â€¢ Simple but loses data                                       â”‚
â”‚                                                                 â”‚
â”‚  Option 2: Vector Clocks                                        â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                   â”‚
â”‚  â€¢ Track version per node                                      â”‚
â”‚  â€¢ Detect conflicts (concurrent writes)                       â”‚
â”‚  â€¢ Application resolves conflicts                             â”‚
â”‚                                                                 â”‚
â”‚  Vector Clock Example:                                          â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                         â”‚
â”‚  Initial: value=A, vc={N1:1}                                  â”‚
â”‚                                                                 â”‚
â”‚  Client 1 on N1: value=B, vc={N1:2}                          â”‚
â”‚  Client 2 on N2: value=C, vc={N1:1, N2:1}                    â”‚
â”‚                                                                 â”‚
â”‚  Conflict! Neither dominates the other                        â”‚
â”‚  Return both: [(B, {N1:2}), (C, {N1:1, N2:1})]               â”‚
â”‚  Client must merge                                             â”‚
â”‚                                                                 â”‚
â”‚  Option 3: CRDTs                                                â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                              â”‚
â”‚  â€¢ Conflict-free data types                                   â”‚
â”‚  â€¢ Automatic merge (counters, sets, etc.)                     â”‚
â”‚  â€¢ Limited to specific operations                             â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 8. Storage Engine

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   STORAGE ENGINE (LSM Tree)                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  Write Path:                                                    â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                   â”‚
â”‚  1. Write to Write-Ahead Log (WAL) on disk                    â”‚
â”‚  2. Insert into in-memory MemTable (sorted)                   â”‚
â”‚  3. When MemTable full â†’ flush to SSTable on disk             â”‚
â”‚                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                                                         â”‚   â”‚
â”‚  â”‚  Write â†’ WAL â†’ MemTable â†’ SSTable (L0)                â”‚   â”‚
â”‚  â”‚                              â”‚                          â”‚   â”‚
â”‚  â”‚                          Compaction                     â”‚   â”‚
â”‚  â”‚                              â–¼                          â”‚   â”‚
â”‚  â”‚                         SSTable (L1)                   â”‚   â”‚
â”‚  â”‚                              â”‚                          â”‚   â”‚
â”‚  â”‚                          Compaction                     â”‚   â”‚
â”‚  â”‚                              â–¼                          â”‚   â”‚
â”‚  â”‚                         SSTable (L2)                   â”‚   â”‚
â”‚  â”‚                                                         â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                 â”‚
â”‚  Read Path:                                                     â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                    â”‚
â”‚  1. Check MemTable                                             â”‚
â”‚  2. Check Bloom filters for each SSTable                      â”‚
â”‚  3. Read from SSTable if Bloom filter says "maybe"           â”‚
â”‚                                                                 â”‚
â”‚  Bloom Filters:                                                 â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                â”‚
â”‚  â€¢ Probabilistic: no false negatives                          â”‚
â”‚  â€¢ Skip SSTables that definitely don't have key              â”‚
â”‚  â€¢ Huge read performance improvement                          â”‚
â”‚                                                                 â”‚
â”‚  Compaction:                                                    â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                   â”‚
â”‚  â€¢ Merge SSTables, remove duplicates/tombstones               â”‚
â”‚  â€¢ Leveled: L0 â†’ L1 â†’ L2 (size ratio ~10x)                   â”‚
â”‚  â€¢ Background process                                          â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 9. Failure Handling

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   FAILURE HANDLING                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  Node Failure Detection:                                        â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                      â”‚
â”‚  â€¢ Gossip protocol: nodes exchange state                      â”‚
â”‚  â€¢ Failure detector: no heartbeat â†’ suspected                 â”‚
â”‚  â€¢ Consensus: majority agrees â†’ confirmed dead                â”‚
â”‚                                                                 â”‚
â”‚  Handling Temporary Failures (Hinted Handoff):                 â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                â”‚
â”‚  1. Node N2 is down                                            â”‚
â”‚  2. Write for N2 goes to N3 with "hint"                       â”‚
â”‚  3. N3 stores hint: "deliver to N2 when back"                â”‚
â”‚  4. N2 comes back, N3 sends hinted writes                     â”‚
â”‚                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  Normal:          N2 Down:          N2 Recovery:       â”‚   â”‚
â”‚  â”‚                                                         â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”           â”Œâ”€â”€â”€â”              â”Œâ”€â”€â”€â”             â”‚   â”‚
â”‚  â”‚  â”‚N1 â”‚           â”‚N1 â”‚              â”‚N1 â”‚             â”‚   â”‚
â”‚  â”‚  â””â”€â”¬â”€â”˜           â””â”€â”¬â”€â”˜              â””â”€â”€â”€â”˜             â”‚   â”‚
â”‚  â”‚    â”‚               â”‚                                   â”‚   â”‚
â”‚  â”‚    â–¼               â–¼                  â”Œâ”€â”€â”€â”           â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”           â”Œâ”€â”€â”€â” (down)        â”‚N2 â”‚â—€â”€â”€hints   â”‚   â”‚
â”‚  â”‚  â”‚N2 â”‚           â”‚N2 â”‚X              â””â”€â”€â”€â”˜            â”‚   â”‚
â”‚  â”‚  â””â”€â”¬â”€â”˜           â””â”€â”€â”€â”˜                  â–²             â”‚   â”‚
â”‚  â”‚    â”‚               â”‚                    â”‚             â”‚   â”‚
â”‚  â”‚    â–¼               â–¼                  â”Œâ”€â”´â”€â”           â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”           â”Œâ”€â”€â”€â” + hints       â”‚N3 â”‚           â”‚   â”‚
â”‚  â”‚  â”‚N3 â”‚           â”‚N3 â”‚               â””â”€â”€â”€â”˜           â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”˜           â””â”€â”€â”€â”˜                               â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                 â”‚
â”‚  Anti-Entropy (Merkle Trees):                                   â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                 â”‚
â”‚  â€¢ Build hash tree of data                                     â”‚
â”‚  â€¢ Compare trees between replicas                             â”‚
â”‚  â€¢ Sync only differing branches                               â”‚
â”‚  â€¢ Periodic background repair                                  â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 10. Technology Choices

| Component | Technology | Rationale |
|-----------|------------|-----------|
| Storage Engine | RocksDB (LSM) | Write-optimized |
| Coordination | Gossip (Swim) | Decentralized |
| Serialization | Protocol Buffers | Efficient |
| Networking | gRPC | High performance |
| Consistency | Quorum-based | Tunable |
| Hashing | MurmurHash | Fast, uniform |

---

## 11. Key Takeaways

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   KEY TAKEAWAYS                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  1. CONSISTENT HASHING                                          â”‚
â”‚     Minimal data movement on scaling                           â”‚
â”‚                                                                 â”‚
â”‚  2. TUNABLE CONSISTENCY                                         â”‚
â”‚     W + R > N for strong consistency                           â”‚
â”‚                                                                 â”‚
â”‚  3. LSM TREE                                                    â”‚
â”‚     Write-optimized storage engine                             â”‚
â”‚                                                                 â”‚
â”‚  4. HINTED HANDOFF                                              â”‚
â”‚     Handle temporary failures gracefully                       â”‚
â”‚                                                                 â”‚
â”‚  5. VECTOR CLOCKS                                               â”‚
â”‚     Detect and resolve conflicts                               â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 12. References

- [14-distributed-patterns.md](/system-design/fundamentals/14-distributed-patterns.md) - Consensus
- [04-consistent-hashing.md](/system-design/fundamentals/12-consistent-hashing.md) - Partitioning
- [11-databases.md](/system-design/fundamentals/11-database-scaling.md) - Storage engines

---

[â† Back to Problems](/system-design/problems/00-index.md) | [Next: News Feed Ranking â†’](/system-design/problems/20-news-feed-ranking.md)
